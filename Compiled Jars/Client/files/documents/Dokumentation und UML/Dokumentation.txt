Softwareentwicklungspraktikum WS13/14

Dokumentation Carcassonne Gruppe: Lannister



Server/Client:

Ein Client versucht sich mit dem Server ueber den listen-ServerSocket zu verbinden.

Gelingt dies wird ein neuer ClientHandler auf der Serverseite gestartet.
Dieser bekommt einen Socket, ueber welchen zukuenftig die komplette
Kommunikation zwischen Server und diesem Client ablaeuft.
In ServerControl wird dieser neue ClientHandler in einer Datenstruktur gespeichert, um spaeter an die verschiedenen Clients Nachrichten schicken zu koennen.
Es wird zudem ein User-Objekt erzeugt, welches dem Client-Handler zugewiesen ist. (Die User-Klasse dient zur Verwaltung eines Users und
speichert entsprechend seinen Nickname, score, color, etc.)
Anfangs werden nur die fuer den Chat relevanten Informationen, wie nickname gesetzt. 
Die fuer das Spiel relevanten Informationen werden dann bei der Spielerzeugung gesetzt.

Der ClientHandler erzeugt sich einen ServerMessageSender, sowie einen ServerMessageReceiver.
Diese 2 Klassen dienen zur Kommunikation zwischen dem Server (genauer
dem ClientHandler) und dem Client. 
Diese 2 Klassen zerlegen bzw. verpacken JSON-Nachrichten und teilen diese dem ClientHandler mit, der sie weiterverarbeitet.

Servercontrol implementiert das Singleton-Pattern, da dies die zentrale
Klasse im Server-Model ist. Es soll nur ein einziges Objekt davon geben,
da dort alle verbundenen Clients und games, sowie der listen-Socket verwaltet werden.





Spiellogik/Spielkarten erstellen

Die zentrale Logik zum erstellen von Spielkarten findet in einem shared-Folder statt. Auf diesen können sowohl Server wie auch Client zugreifen und sich die für ihre Zwecke passenden Informationen besorgen.
Die Spielkarte besteht aus zwei Teilen:
1. Dem zugehörigen Bild, welches der Spieler letztendlich sieht. Diese einzelnen Bilder werden abgespeichert und alphabetisch durchnummeriert. Der Buchstabe ist dabei die ID mit welcher das Bild zur zugehörigen Logik zugeordnet wird.
2. Der Logik mithilfe welcher die Karten aneinander gelegt werden können, Meeples gesetzt und Punkte vergeben werden können. Die Spielkarte wird in insgesamt 12 Teile unterteilt. 3 mal 4 für die einzelnen Ränder und 1 für die Mitte der Karte. Dies ist nötig da somit jeder Rand für sich genommen betrachtet werden kann.

Die Anordnung der Teilfelder einer Spielkarte:

           0 1 2
	11       3
	10  12   4
	 9       5
	   8 7 6

Bsp: Sei eine Karte mit einem Stadtstück als Nordkante und den restlichen Kanten Weg und Wiese gegeben. Falls nun an die Kante Nord angelegt werden soll werden die Felder 0,1,2 betrachtet welche alle city aufweisen. Will man dagegen an die Kante Ost anlegen werden die Stücke 3,4,5 betrachtet welche Wiese,Weg,Wiese sind. bei gröberer Differenzierung hätte man ansonsten ein Problem bei der Betrachtung der Ecke NordOst was somit nicht gegeben ist. 

Die Logik der Spielkarten werden in einer XML-Datei gespeichert. Und zwar wie folgt: 

<tile id="A" occurrence="2">
	<city> </city>
	<meadow> 0,1,2,3,4,5,6,8,9,10,11 </meadow>
	<monastery> 12 </monastery>
	<road> 7 </road>
</tile>

Dieses Beispiel zeigt die Logik einer Spielkarte mit der id = A und der Häufigkeit von 2. Klar zu erkennen ist das es sich um ein Kloster in der Mitte der Karte handelt zu dem ein Weg führt. An jedem anderen Kartenstück befindet sich Wiese.

Die XML-Datei wird in der Klasse LogicCardCreator eingelesen und der Kartenstapel, sowie die einzelnen Spielkarten(Tiles) gebildet. Sie verfügt über Methoden wie buildCard(), buildCardDeck() und einen fileReader(). Die Klasse ImageCardCreator liefert das zugehörige Bild indem es die id und das Bild zusammen in einer Map abspeichert. Die Klasse Card repräsentiert eine Karte mit zugehörigen Methoden(rotate etc.). Die  Klasse cardDeck repräsentiert den Kartenstapel. Dieser soll über Methoden verfügen mit deren Hilfe man den Stapel vor dem Spiel mischen kann, die erste karte entnehmen, sowie auf die StartKarte zugreifen kann. Um die Spielkarte zu erstellen müssen die einzelnen 12 TeilKartenfelder aus der XML-Datei noch zugeordnet werden. Dies soll in der Klasse cardAreaType geschehen. Die Klasse soll die ausgelesen Felder auf der Spielkarte anordnen und diese der Klasse Card übergeben. 

Der Server benötigt hierbei nur die Logik der Spielkarten um die Spielzüge zu überprüfen, wohingegen der Client auch die Images benötigt.



